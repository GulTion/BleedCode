const C2O = {'+':0,'-':1,'×':2,'/':3,'(':4,')':5,'^':6};
const O2C = ['+','-','*','/','(',')','^'];
const REM = 7; // Code for Removal operation
const MAX_IDX = 31; // Maximum index storable in 5 bits (0-31)

/**
 * Calculates the difference between two strings (s1 -> s2) as a single byte.
 * The byte encodes the operation (insert operator or remove character) and the index.
 * Assumes the difference is a single character insertion (from O2C) or deletion.
 * Returns null if the difference is not representable this way, identical, or index > MAX_IDX.
 *
 * Byte format: [op: 3 bits][index: 5 bits]
 * op: 0-6 correspond to O2C, 7 (REM) means removal.
 * index: 0-31 indicates the position of the change.
 */
export function calcDiff(s1, s2) {
    const l1 = s1.length;
    const l2 = s2.length;
    let i = 0;
    // Find the first differing index
    while (i < l1 && i < l2 && s1[i] === s2[i]) {
        i++;
    }

    // If index is too large, difference is too far along the string
    if (i > MAX_IDX) return null;

    // If strings are identical up to their shared length and have the same length
    if (i === l1 && i === l2) return null; // No difference

    let op = -1;

    // Check for single character deletion (s1 is one longer, rest matches)
    if (l1 === l2 + 1 && s1.slice(i + 1) === s2.slice(i)) {
        op = REM; // Deletion occurred at index i in s1
    }
    // Check for single character insertion (s2 is one longer, rest matches)
    else if (l2 === l1 + 1 && s2.slice(i + 1) === s1.slice(i)) {
        const charInserted = s2[i];
        // Check if the inserted character is a valid operator we can encode
        if (charInserted !== undefined && charInserted in C2O) {
            op = C2O[charInserted]; // Insertion occurred at index i
        } else {
            // Inserted character is not a known operator or invalid
            return null;
        }
    }
    // If neither single insertion nor deletion matches, the diff is too complex
    else {
        return null;
    }

    // Should have a valid op (0-7) by now
    if (op === -1) {
       return null; // Should not happen if logic above is correct, but safety check
    }

    // Encode operation (3 bits) and index (5 bits) into a byte
    return (op << 5) | i;
}

/**
 * Applies a patch byte (generated by calcDiff) to a string s1.
 * Returns the resulting string s2, or null if the patch is invalid.
 */
export function applyPatch(s1, byte) {
    // Basic validation of the byte
    if (byte === null || byte < 0 || byte > 255) return null;

    // Decode the operation (top 3 bits) and index (bottom 5 bits)
    const op = byte >> 5;
    const idx = byte & MAX_IDX; // equivalent to byte % 32
    const l1 = s1.length;

    // Handle REMoval operation
    if (op === REM) {
        // Check if index is valid for removal (must be within current string bounds)
        if (idx >= l1) return null;
        // Return string with character at idx removed
        return s1.slice(0, idx) + s1.slice(idx + 1);
    }
    // Handle INsertion operations (op codes 0-6)
    else if (op < REM) {
        const charToInsert = O2C[op];
        // Check if the decoded operation corresponds to a valid character
        if (charToInsert === undefined) return null;
        // Check if index is valid for insertion (can insert at the end, so idx <= l1)
        if (idx > l1) return null;
        // Return string with the character inserted at idx
        return s1.slice(0, idx) + charToInsert + s1.slice(idx);
    }
    // Invalid operation code (shouldn't happen with byte 0-255 if op >= 0)
    else {
        return null;
    }
}

/**
 * Reconstructs the sequence of states from initial digits and a list of diff bytes.
 */
export function stateMakerFromDiff(digits, stateDiff) {
    // Ensure digits is an array, join to create initial string
    let s = Array.isArray(digits) ? digits.join("") : String(digits);
    let currentState = s;
    const res = [];
    // Push the initial state only if needed by consumer, often it's implicit
    // res.push({ state: currentState }); // Optional: include initial state

    for (let i = 0; i < stateDiff.length; ++i) {
        const nextState = applyPatch(currentState, stateDiff[i]);
        // If patch fails, stop processing or handle error
        if (nextState === null) {
            console.error(`Failed to apply patch byte ${stateDiff[i]} (op=${stateDiff[i] >> 5}, idx=${stateDiff[i] & MAX_IDX}) to state "${currentState}"`);
            // Option 1: Stop and return partial result
            return res;
            // Option 2: Skip this diff and continue (might lead to inconsistencies)
            // continue;
        }
        currentState = nextState;
        res.push({ state: currentState });
    }
    return res;
}

/**
 * Generates a sequence of diff bytes from a list of states.
 * The first state is the baseline.
 */
export function stateDiffMakerFromState(state) {
    // Requires at least two states to make a diff
    if (!Array.isArray(state) || state.length < 2) {
        return [];
    }
    const res = [];
    for (let i = 1; i < state.length; ++i) {
        const diffByte = calcDiff(state[i-1], state[i]);
        // If calcDiff returns null, the sequence is invalid according to the diff logic
        if (diffByte === null) {
             console.error(`Cannot calculate valid single-op diff between "${state[i-1]}" and "${state[i]}" at step ${i}`);
             // Option 1: Stop and return partial result
             return res;
             // Option 2: Push null and continue (consumer must handle nulls)
             // res.push(null);
             // continue;
        }
        res.push(diffByte);
    }
    return res;
}

let state = ['936184', '936184×', '936184', '93618×4', '93618×4(', '93618×4', '9361(8×4', '9361(8×4)', '9361(8×4)+', '9361(8×4)', '9361+(8×4)', '9361+(8×4)-', '9361+(8×4)', '936-1+(8×4)', '936-1+(8×4)^', '936-1+(8×4)', '93^6-1+(8×4)', '93^61+(8×4)', '9-3^61+(8×4)', '9-3^61+(8×4)(', '9-3^61+(8×4)', '9-3^6(1+(8×4)', '9-3^6(1+(8×4))', '9-3^6(1+(8×4))×', '9-3^6(1+(8×4))', '9-3^6×(1+(8×4))']

console.log(stateMakerFromDiff([9,3,6,1,8,4],stateDiffMakerFromState(state)))